'use strict';

exports.__esModule = true;

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _testRun = require('./test-run');

var _testRunState = require('./test-run-state');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class LiveModeTestRunController extends _events2.default {
    constructor() {
        super();

        this.RUN_FINISHED_EVENT = 'run-finished-event';
        this.RUN_STOPPED_EVENT = 'run-stopped-event';

        this.testWrappers = [];
        this.expectedTestCount = 0;
        this._testRunCtor = null;
    }

    get TestRunCtor() {
        if (!this._testRunCtor) {
            this._testRunCtor = (0, _testRun.TestRunCtorFactory)({
                created: testRun => this._onTestRunCreated(testRun),
                started: testRun => this._onTestRunStarted(testRun),
                done: (testRun, forced) => this._onTestRunDone(testRun, forced),
                readyToNext: testRun => this._onTestRunReadyToNext(testRun)
            });
        }

        return this._testRunCtor;
    }

    run(testCount) {
        const readyToNextPromises = [];

        this.expectedTestCount = testCount;

        this.testWrappers.forEach(testWrapper => {
            testWrapper.testRuns.forEach(testRun => {
                if (testRun.finish) {
                    readyToNextPromises.push(testRun.readyToNextPromise);
                    testRun.finish();
                }
            });
        });

        this.testWrappers = [];

        return _pinkie2.default.all(readyToNextPromises);
    }

    stop() {
        const runningTestWrappers = this.testWrappers.filter(w => w.state === _testRunState.TEST_STATE.running);

        runningTestWrappers.forEach(testWrapper => {
            testWrapper.testRuns.forEach(testRun => testRun.stop());
        });
    }

    _onTestRunCreated(testRun) {
        const testWrapper = {
            state: _testRunState.TEST_STATE.created,
            testRuns: [testRun]
        };

        testRun.testWrapper = testWrapper;

        this.testWrappers.push(testWrapper);
    }

    _onTestRunStarted(testRun) {
        testRun.state = _testRunState.TEST_RUN_STATE.running;
        testRun.testWrapper.state = _testRunState.TEST_STATE.running;
    }

    _onTestRunDone(testRun, forced) {
        const testWrapper = testRun.testWrapper;

        testRun.state = _testRunState.TEST_RUN_STATE.waitingForDone;

        const waitingTestRunCount = testWrapper.testRuns.filter(w => w.state === _testRunState.TEST_RUN_STATE.created).length;
        const runningTestRunCount = testWrapper.testRuns.filter(w => w.state === _testRunState.TEST_RUN_STATE.running).length;

        const waitForOtherTestRuns = runningTestRunCount || waitingTestRunCount && !forced;

        if (!waitForOtherTestRuns) {
            testWrapper.state = _testRunState.TEST_STATE.done;

            //check other active tests
            setTimeout(() => {
                const hasTestsToRun = this.testWrappers.length < this.expectedTestCount || this.testWrappers.some(w => w.state === _testRunState.TEST_STATE.created) || testRun.quarantine && !testRun.quarantine.isThresholdReached();

                if (!forced && hasTestsToRun) testWrapper.testRuns.forEach(w => w.finish());else this.emit(forced ? this.RUN_STOPPED_EVENT : this.RUN_FINISHED_EVENT);
            }, 0);
        }

        testRun.readyToNextPromise = new _pinkie2.default(resolve => {
            testRun.setReadyToNext = resolve;
        });

        return new _pinkie2.default(resolve => {
            testRun.finish = () => {
                testRun.finish = null;
                testRun.state = _testRunState.TEST_RUN_STATE.done;
                resolve();
            };
        });
    }

    _onTestRunReadyToNext(testRun) {
        testRun.setReadyToNext();
    }
}

exports.default = LiveModeTestRunController;
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saXZlL3Rlc3QtcnVuLWNvbnRyb2xsZXIuanMiXSwibmFtZXMiOlsiTGl2ZU1vZGVUZXN0UnVuQ29udHJvbGxlciIsIkV2ZW50RW1pdHRlciIsImNvbnN0cnVjdG9yIiwiUlVOX0ZJTklTSEVEX0VWRU5UIiwiUlVOX1NUT1BQRURfRVZFTlQiLCJ0ZXN0V3JhcHBlcnMiLCJleHBlY3RlZFRlc3RDb3VudCIsIl90ZXN0UnVuQ3RvciIsIlRlc3RSdW5DdG9yIiwiY3JlYXRlZCIsInRlc3RSdW4iLCJfb25UZXN0UnVuQ3JlYXRlZCIsInN0YXJ0ZWQiLCJfb25UZXN0UnVuU3RhcnRlZCIsImRvbmUiLCJmb3JjZWQiLCJfb25UZXN0UnVuRG9uZSIsInJlYWR5VG9OZXh0IiwiX29uVGVzdFJ1blJlYWR5VG9OZXh0IiwicnVuIiwidGVzdENvdW50IiwicmVhZHlUb05leHRQcm9taXNlcyIsImZvckVhY2giLCJ0ZXN0V3JhcHBlciIsInRlc3RSdW5zIiwiZmluaXNoIiwicHVzaCIsInJlYWR5VG9OZXh0UHJvbWlzZSIsIlByb21pc2UiLCJhbGwiLCJzdG9wIiwicnVubmluZ1Rlc3RXcmFwcGVycyIsImZpbHRlciIsInciLCJzdGF0ZSIsIlRFU1RfU1RBVEUiLCJydW5uaW5nIiwiVEVTVF9SVU5fU1RBVEUiLCJ3YWl0aW5nRm9yRG9uZSIsIndhaXRpbmdUZXN0UnVuQ291bnQiLCJsZW5ndGgiLCJydW5uaW5nVGVzdFJ1bkNvdW50Iiwid2FpdEZvck90aGVyVGVzdFJ1bnMiLCJzZXRUaW1lb3V0IiwiaGFzVGVzdHNUb1J1biIsInNvbWUiLCJxdWFyYW50aW5lIiwiaXNUaHJlc2hvbGRSZWFjaGVkIiwiZW1pdCIsInJlc29sdmUiLCJzZXRSZWFkeVRvTmV4dCJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7OztBQUVBLE1BQU1BLHlCQUFOLFNBQXdDQyxnQkFBeEMsQ0FBcUQ7QUFDakRDLGtCQUFlO0FBQ1g7O0FBRUEs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VyxLQUFaLEdBQW9CQyx5QkFBV3JCLElBQS9COztBQUVBO0FBQ0E2Qix1QkFBVyxNQUFNO0FBQ2Isc0JBQU1DLGdCQUFnQixLQUFLdkMsWUFBTCxDQUFrQm1DLE1BQWxCLEdBQTJCLEtBQUtsQyxpQkFBaEMsSUFDQSxLQUFLRCxZQUFMLENBQWtCd0MsSUFBbEIsQ0FBdUJaLEtBQUtBLEVBQUVDLEtBQUYsS0FBWUMseUJBQVcxQixPQUFuRCxDQURBLElBRUFDLFFBQVFvQyxVQUFSLElBQXNCLENBQUNwQyxRQUFRb0MsVUFBUixDQUFtQkMsa0JBQW5CLEVBRjdDOztBQUlBLG9CQUFJLENBQUNoQyxNQUFELElBQVc2QixhQUFmLEVBQ0lyQixZQUFZQyxRQUFaLENBQXFCRixPQUFyQixDQUE2QlcsS0FBS0EsRUFBRVIsTUFBRixFQUFsQyxFQURKLEtBR0ksS0FBS3VCLElBQUwsQ0FBVWpDLFNBQVMsS0FBS1gsaUJBQWQsR0FBa0MsS0FBS0Qsa0JBQWpEO0FBQ1AsYUFURCxFQVNHLENBVEg7QUFVSDs7QUFFRE8sZ0JBQVFpQixrQkFBUixHQUE2QixJQUFJQyxnQkFBSixDQUFZcUIsV0FBVztBQUNoRHZDLG9CQUFRd0MsY0FBUixHQUF5QkQsT0FBekI7QUFDSCxTQUY0QixDQUE3Qjs7QUFJQSxlQUFPLElBQUlyQixnQkFBSixDQUFZcUIsV0FBVztBQUMxQnZDLG9CQUFRZSxNQUFSLEdBQWlCLE1BQU07QUFDbkJmLHdCQUFRZSxNQUFSLEdBQWlCLElBQWpCO0FBQ0FmLHdCQUFRd0IsS0FBUixHQUFpQkcsNkJBQWV2QixJQUFoQztBQUNBbUM7QUFDSCxhQUpEO0FBS0gsU0FOTSxDQUFQO0FBT0g7O0FBRUQvQiwwQkFBdUJSLE9BQXZCLEVBQWdDO0FBQzVCQSxnQkFBUXdDLGNBQVI7QUFDSDtBQTdHZ0Q7O2tCQWdIdENsRCx5QiIsImZpbGUiOiJsaXZlL3Rlc3QtcnVuLWNvbnRyb2xsZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgUHJvbWlzZSBmcm9tICdwaW5raWUnO1xuaW1wb3J0IHsgVGVzdFJ1bkN0b3JGYWN0b3J5IH0gZnJvbSAnLi90ZXN0LXJ1bic7XG5pbXBvcnQgeyBURVNUX1NUQVRFLCBURVNUX1JVTl9TVEFURSB9IGZyb20gJy4vdGVzdC1ydW4tc3RhdGUnO1xuXG5jbGFzcyBMaXZlTW9kZVRlc3RSdW5Db250cm9sbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHN1cGVyKCk7XG5cbiAgICAgICAgdGhpcy5SVU5fRklOSVNIRURfRVZFTlQgPSAncnVuLWZpbmlzaGVkLWV2ZW50JztcbiAgICAgICAgdGhpcy5SVU5fU1RPUFBFRF9FVkVOVCAgPSAncnVuLXN0b3BwZWQtZXZlbnQnO1xuXG4gICAgICAgIHRoaXMudGVzdFdyYXBwZXJzICAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5leHBlY3RlZFRlc3RDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX3Rlc3RSdW5DdG9yICAgICAgPSBudWxsO1xuICAgIH1cblxuICAgIGdldCBUZXN0UnVuQ3RvciAoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdGVzdFJ1bkN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rlc3RSdW5DdG9yID0gVGVzdFJ1bkN0b3JGYWN0b3J5KHtcbiAgICAgICAgICAgICAgICBjcmVhdGVkOiAgICAgdGVzdFJ1biA9PiB0aGlzLl9vblRlc3RSdW5DcmVhdGVkKHRlc3RSdW4pLFxuICAgICAgICAgICAgICAgIHN0YXJ0ZWQ6ICAgICB0ZXN0UnVuID0+IHRoaXMuX29uVGVzdFJ1blN0YXJ0ZWQodGVzdFJ1biksXG4gICAgICAgICAgICAgICAgZG9uZTogICAgICAgICh0ZXN0UnVuLCBmb3JjZWQpID0+IHRoaXMuX29uVGVzdFJ1bkRvbmUodGVzdFJ1biwgZm9yY2VkKSxcbiAgICAgICAgICAgICAgICByZWFkeVRvTmV4dDogdGVzdFJ1biA9PiB0aGlzLl9vblRlc3RSdW5SZWFkeVRvTmV4dCh0ZXN0UnVuKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdGVzdFJ1bkN0b3I7XG4gICAgfVxuXG4gICAgcnVuICh0ZXN0Q291bnQpIHtcbiAgICAgICAgY29uc3QgcmVhZHlUb05leHRQcm9taXNlcyA9IFtdO1xuXG4gICAgICAgIHRoaXMuZXhwZWN0ZWRUZXN0Q291bnQgPSB0ZXN0Q291bnQ7XG5cbiAgICAgICAgdGhpcy50ZXN0V3JhcHBlcnMuZm9yRWFjaCh0ZXN0V3JhcHBlciA9PiB7XG4gICAgICAgICAgICB0ZXN0V3JhcHBlci50ZXN0UnVucy5mb3JFYWNoKHRlc3RSdW4gPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0ZXN0UnVuLmZpbmlzaCkge1xuICAgICAgICAgICAgICAgICAgICByZWFkeVRvTmV4dFByb21pc2VzLnB1c2godGVzdFJ1bi5yZWFkeVRvTmV4dFByb21pc2UpO1xuICAgICAgICAgICAgICAgICAgICB0ZXN0UnVuLmZpbmlzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnRlc3RXcmFwcGVycyA9IFtdO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZWFkeVRvTmV4dFByb21pc2VzKTtcbiAgICB9XG5cbiAgICBzdG9wICgpIHtcbiAgICAgICAgY29uc3QgcnVubmluZ1Rlc3RXcmFwcGVycyA9IHRoaXMudGVzdFdyYXBwZXJzLmZpbHRlcih3ID0+IHcuc3RhdGUgPT09IFRFU1RfU1RBVEUucnVubmluZyk7XG5cbiAgICAgICAgcnVubmluZ1Rlc3RXcmFwcGVycy5mb3JFYWNoKHRlc3RXcmFwcGVyID0+IHtcbiAgICAgICAgICAgIHRlc3RXcmFwcGVyLnRlc3RSdW5zLmZvckVhY2godGVzdFJ1biA9PiB0ZXN0UnVuLnN0b3AoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9vblRlc3RSdW5DcmVhdGVkICh0ZXN0UnVuKSB7XG4gICAgICAgIGNvbnN0IHRlc3RXcmFwcGVyID0ge1xuICAgICAgICAgICAgc3RhdGU6ICAgIFRFU1RfU1RBVEUuY3JlYXRlZCxcbiAgICAgICAgICAgIHRlc3RSdW5zOiBbdGVzdFJ1bl1cbiAgICAgICAgfTtcblxuICAgICAgICB0ZXN0UnVuLnRlc3RXcmFwcGVyID0gdGVzdFdyYXBwZXI7XG5cbiAgICAgICAgdGhpcy50ZXN0V3JhcHBlcnMucHVzaCh0ZXN0V3JhcHBlcik7XG4gICAgfVxuXG4gICAgX29uVGVzdFJ1blN0YXJ0ZWQgKHRlc3RSdW4pIHtcbiAgICAgICAgdGVzdFJ1bi5zdGF0ZSAgICAgICAgICAgICA9IFRFU1RfUlVOX1NUQVRFLnJ1bm5pbmc7XG4gICAgICAgIHRlc3RSdW4udGVzdFdyYXBwZXIuc3RhdGUgPSBURVNUX1NUQVRFLnJ1bm5pbmc7XG4gICAgfVxuXG4gICAgX29uVGVzdFJ1bkRvbmUgKHRlc3RSdW4sIGZvcmNlZCkge1xuICAgICAgICBjb25zdCB0ZXN0V3JhcHBlciA9IHRlc3RSdW4udGVzdFdyYXBwZXI7XG5cbiAgICAgICAgdGVzdFJ1bi5zdGF0ZSA9IFRFU1RfUlVOX1NUQVRFLndhaXRpbmdGb3JEb25lO1xuXG4gICAgICAgIGNvbnN0IHdhaXRpbmdUZXN0UnVuQ291bnQgPSB0ZXN0V3JhcHBlci50ZXN0UnVucy5maWx0ZXIodyA9PiB3LnN0YXRlID09PSBURVNUX1JVTl9TVEFURS5jcmVhdGVkKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJ1bm5pbmdUZXN0UnVuQ291bnQgPSB0ZXN0V3JhcHBlci50ZXN0UnVucy5maWx0ZXIodyA9PiB3LnN0YXRlID09PSBURVNUX1JVTl9TVEFURS5ydW5uaW5nKS5sZW5ndGg7XG5cbiAgICAgICAgY29uc3Qgd2FpdEZvck90aGVyVGVzdFJ1bnMgPSBydW5uaW5nVGVzdFJ1bkNvdW50IHx8IHdhaXRpbmdUZXN0UnVuQ291bnQgJiYgIWZvcmNlZDtcblxuICAgICAgICBpZiAoIXdhaXRGb3JPdGhlclRlc3RSdW5zKSB7XG4gICAgICAgICAgICB0ZXN0V3JhcHBlci5zdGF0ZSA9IFRFU1RfU1RBVEUuZG9uZTtcblxuICAgICAgICAgICAgLy9jaGVjayBvdGhlciBhY3RpdmUgdGVzdHNcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc1Rlc3RzVG9SdW4gPSB0aGlzLnRlc3RXcmFwcGVycy5sZW5ndGggPCB0aGlzLmV4cGVjdGVkVGVzdENvdW50IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGVzdFdyYXBwZXJzLnNvbWUodyA9PiB3LnN0YXRlID09PSBURVNUX1NUQVRFLmNyZWF0ZWQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RSdW4ucXVhcmFudGluZSAmJiAhdGVzdFJ1bi5xdWFyYW50aW5lLmlzVGhyZXNob2xkUmVhY2hlZCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZWQgJiYgaGFzVGVzdHNUb1J1bilcbiAgICAgICAgICAgICAgICAgICAgdGVzdFdyYXBwZXIudGVzdFJ1bnMuZm9yRWFjaCh3ID0+IHcuZmluaXNoKCkpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGZvcmNlZCA/IHRoaXMuUlVOX1NUT1BQRURfRVZFTlQgOiB0aGlzLlJVTl9GSU5JU0hFRF9FVkVOVCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRlc3RSdW4ucmVhZHlUb05leHRQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICB0ZXN0UnVuLnNldFJlYWR5VG9OZXh0ID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGVzdFJ1bi5maW5pc2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGVzdFJ1bi5maW5pc2ggPSBudWxsO1xuICAgICAgICAgICAgICAgIHRlc3RSdW4uc3RhdGUgID0gVEVTVF9SVU5fU1RBVEUuZG9uZTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBfb25UZXN0UnVuUmVhZHlUb05leHQgKHRlc3RSdW4pIHtcbiAgICAgICAgdGVzdFJ1bi5zZXRSZWFkeVRvTmV4dCgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTGl2ZU1vZGVUZXN0UnVuQ29udHJvbGxlcjtcbiJdfQ==
